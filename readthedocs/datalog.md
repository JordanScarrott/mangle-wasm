# Getting to know Datalog

Mangle is based on Datalog. Datalog is a minimal formal language
that lets us talk about databases and queries. In order
to learn Mangle, one has to learn Datalog first.

Fortunately, Datalog is easy to learn and has very few concepts.
In this section, we introduce these concepts in passing through an example:
a database of volunteers and their skills.
Take a look at this table:

| ID | Name | Skill |
|----|------|-------|
| 1 | Aisha Salehi| Teaching |
| 2 | Xin Watson  | Workshop Facilitation |
| 3 | Alyssa P. Hacker  | Software Development |

The Datalog view of a table is that it is an enumeration of
facts. We can write a program that generates
facts:

```
volunteer(1, "Aisha Salehi", /teaching).
volunteer(2, "Xin Watson", /workshop_facilitation).
volunteer(3, "Alyssa P. Hacker", /software_development).
```

The above program contains rules. They are special cases of rules,
since they just state facts, without any premises.

Normally, a database is not defined within a program, but given outside.
This is just an example to get familiar.

## Atoms and Matching

A rule describes how to obtain new facts from existing ones. Before we look
at rules, we need to understand matching.

We can variables like `X` as placeholders to describe fact patterns. Such
fact patterns are called atoms. A known fact can match an atom when there is a
way to assign values to the atom's variables that make the atom and the fact
equal. So the fact `volunteer(3, "Alyssa P. Hacker", /software_development)`
matches the atom `volunteer(1, "Aisha Salehi", X)` because we can set
`X` to `/software_development`.

Now we can define a proper rule. Let's define one that picks
everyone who has the `/teaching` skill:

```
teacher(ID, Name) ⟸ volunteer(ID, Name, /software_development).
```

(Mangle Datalog also supports the older notation `:-` instead of `⟸`.)

This rule involves variables `ID` and `Name`. When we use variables, there
is a condition that needs to be met, which we describe below.

Conceptually, we can imagine that a Datalog engine will try out all
possible combination of values that could lead to a match for each atom in the
body. When this is successful, the engine uses the variable assignment to
create a new fact.

Rules can database:

- we can think of rules as a database queries
- we can also think of rules as defining a new table `teacher` and
populating it with a subset of the rows from table `volunteer`.

## Multiple atoms and multiple rules

Our example is not very realistic, as every volunteer has exactly
one skill. Let's fix this:

| ID | Name | Skills |
|----|------|-------|
| 1 | Aisha Salehi| Teaching, Workshop Facilitation |
| 2 | Xin Watson  | Workshop Facilitation |
| 3 | Alyssa P. Hacker  | Software Development, Workshop Facilitation |

One way to turn this into facts it to duplicate values (denormalization):

```
volunteer(1, "Aisha Salehi", /teaching).
volunteer(1, "Aisha Salehi", /workshop_facilitation).
volunteer(2, "Xin Watson", /workshop_facilitation).
volunteer(3, "Alyssa P. Hacker", /software_development).
volunteer(3, "Alyssa P. Hacker", /workshop_facilitation).
```

Suppose we want to organize a coding workshop. There is already a workshop
facilitator but our volunteer organization was asked to supply a teacher and a
software developer.

We can simply write two rules, and the resulting table will be the union
of all facts that are generated by each one.

```
coding_workshop(ID, Name, /teacher) ⟸
    volunteer(ID, Name, /teacher).
coding_workshop(ID, Name, /software_development) ⟸
    volunteer(ID, Name, /software_development).
```

If instead, we wanted to find all people who know both, teaching and
software development, then we'd use multiple atoms in the body, separated
by a comma:

```
teacher_and_coder(ID, Name) ⟸
    volunteer(ID, Name, /teacher),
    volunteer(ID, Name, /software_development).
```

In our current data set, the result will be empty.

## Recursive rules

Rules can be recursive: when defining a relation using rules, it is
permitted to refer to the relation that is being defined.

Check out the following facts:

```
knows("Aisha", "Xin").
knows("Xin", "Alyssa").
knows("Alyssa", "Selin").
```

We can write a recursive rule that follows the chain of acquaintances.

```
reachable(X, Y) ⟸ knows(X, Y).
reachable(X, Z) ⟸ knows(X, Y), reachable(Y, Z).
```

The first rule says that `reachable` contains all rows of `knows` table.
Conceptually, the second rule says that whenever an entry in the `reachable`
table can be connected further, then a new entry should be added.

Real datalog engines do not need to try out all possible values. They
use more efficient operations such as joins and incremental computation.

## The Safety Condition

To recap, the general form of a rule is that it can have two forms:

* either a fact, followed by a dot. Such a rule has an empty body.
* or a head expression, followed by `⟸` (or the older notation, `:-`),
followed by a body, and a dot. The body can consist of multiple atoms.

The use of variables is subject to a condition: all variables that
appear in the head must also appear in the body. This condition (which we
the safety condition) ensures that a rule is defined: there is an
effective way to find the facts described in the head and that the overall
process terminates.

One consequence is that a rule without a body cannot use any variables.

The safety condition is what justifies our conceptual approach of finding
the values to match the rule body. If there were unused variables in the rule
head, then finding values to mach the body would not be enough to produce a
fact; one would also have to invent arbitrary values for the head variables.
The safety condition ensures that the rules fully determine what gets
computed.

## Naive evaluation

An introduction to Datalog is not complete without a description of the
evaluation algorithm. It is very simple:

1. Start with a set of facts (the extensional database, possibly empty)
2. Repeat until no new fact is added:
  * for every rule
    * use the set of facts to match every atom `p(...)` in the body
    * if successful, add a new fact to the set of facts.

In computer science, this is known as fixed-point computation. We will not
prove termination here but only mention that due to the safety condition
every rule is constrained in what new facts it can produce.

Naive evaluation is very inefficient because it computes the same information
over and over again. It can be used to specify what the meaning of a Datalog
program is, and with this specification, it is possible to build Datalog
engines that compute the result in a more efficient manner.
